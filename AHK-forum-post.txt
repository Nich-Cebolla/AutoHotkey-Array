[color=#800000][size=150]Description[/size][/color]
[color=#000000][size=125]Array.ahk is a library that implements common array methods. The implementations are optimized to require the least number of calculations to produce the intended result. They are based on Javascript, but note that any methods that use an [c]end[/c] parameter in Javascript use a [c]length[/c] parameter here instead.[/size][/color]

[color=#800000][size=150]Github link[/size][/color]
[color=#000000][size=125][url]https://github.com/Nich-Cebolla/AutoHotkey-Array[/url][/color]

[color=#800000][size=150]Features[/size][/color][color=#000000][size=125]
- Array.Prototype.Find
- Array.Prototype.ForEach
- Array.Prototype.IndexOf
- Array.Prototype.Join
- Array.Prototype.Reduce
- Array.Prototype.Reverse
- Array.Prototype.Slice
- Array.Prototype.Splice
- Array.Prototype.JoinA[/size][/color]

[color=#800000][size=150]Array.ahk[/size][/color]

[code]
Array.Prototype.DefineProp('Find', {Call: ARRAY_FIND})
/**
 * @description - Implements Javascript's `array.find` method in AutoHotkey.
 * @param {Array} Arr - The array to search. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Func|BoundFunc|Closure} Callback - The function to execute on each element in the array.
 * The function should return a nonzero value when the condition is met. The function can accept
 * one to three parameters:
 * - The current element being processed in the array.
 * - [Optional] The index of the current element being processed in the array.
 * - [Optional] The array find was called upon.
 * @returns {Any} - The first element in the array that satisfies the condition.
    @example
        OutputDebug([1,2,3,4,5].Find((Item, *) => Item > 3)) ; 4
    @
 */
ARRAY_FIND(Arr, Callback) {
    for Item in Arr {
        if IsSet(Item) && Callback(Item, A_Index, Arr)
            return Item
    }
}

Array.Prototype.DefineProp('ForEach', {Call: ARRAY_FOR_EACH})
/**
 * @description - Implements Javascript's `array.forEach` method in AutoHotkey.
 * `Array.Prototype.ForEach` is used to do an action on every value in an array.
 * @param {Array} Arr - The array to iterate. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Func|BoundFunc|Closure} Callback - The function to call for each element in the array.
 * If using `ThisArg`, this can accept two to four parameters. If not, it can accept one to three:
 * - The value passed to `ThisArg`. (This is only when `ThisArg` is set).
 * - The current element being processed in the array.
 * - [Optional] The index of the current element being processed in the array.
 * - [Optional] The array `ForEach` was called upon.
 * The function does not need a return value, and if one exists it is ignored.
 * @param {Any} [Default] - The value to use when an array index is unset. If `Default` is unset
 * and `ForEach` encounters an unset index, that index is skipped.
 * @param {Object} [ThisArg] - The object to use as `this` when executing the callback.
 */
ARRAY_FOR_EACH(Arr, Callback, Default?, ThisArg?) {
    if IsSet(ThisArg) {
        if IsSet(Default) {
            for Item in Arr
                Callback(ThisArg, Item??Default, A_Index, Arr)
        } else {
            for Item in Arr {
                if IsSet(Item)
                    Callback(ThisArg, Item, A_Index, Arr)
            }
        }
    } else {
        if IsSet(Default) {
            for Item in Arr
                Callback(Item??Default, A_Index, Arr)
        } else {
            for Item in Arr {
                if IsSet(Item)
                    Callback(Item, A_Index, Arr)
            }
        }
    }
}

Array.Prototype.DefineProp('IndexOf', {Call: ARRAY_INDEX_OF})
/**
 * @description - Searches an array for the input value.
 * @param {Array} Arr - The array to search. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Number|String} Item - The value to search for.
 * @param {Integer} [Start=1] - The index to start the search from.
 * @param {Integer} [Length] - The number of elements to search. If unset, the search will continue
 * until the end of the array.
 * @param {Boolean} [StrictType=true] - If true, the search will only return a match if the type of
 * the value in the array matches the type of the input value.
 * @param {Boolean} [CaseSense=true] - If true, the search will be case-sensitive.
 * @returns {Integer} - The index of the first occurrence of the input value in the array. If the
 * value is not found, an empty string is returned.
 */
ARRAY_INDEX_OF(Arr, Item, Start := 1, Length?, StrictType := true, CaseSense := true) {
    if IsObject(Item)
        throw TypeError('Objects cannot be compared by value. Define a hashing function to compare'
        ' objects, or use ``Find`` which searches an array using a callback function.', -1)
    End := IsSet(Length) && Start + Length < Arr.Length ?  Start + Length : Arr.Length
    i := Start - 1
    if CaseSense {
        if StrictType {
            while ++i <= End {
                if Arr.Has(i) && Arr[i] == Item && Type(Arr[i]) == Type(Item)
                    return i
            }
        } else {
            while ++i <= End {
                if Arr.Has(i) && Arr[i] == Item
                    return i
            }
        }
    } else {
        if StrictType {
            while ++i <= End {
                if Arr.Has(i) && Arr[i] = Item && Type(Arr[i]) == Type(Item)
                    return i
            }
        } else {
            while ++i <= End {
                if Arr.Has(i) && Arr[i] = Item
                    return i
            }
        }
    }
}

Array.Prototype.DefineProp('Join', {Call: ARRAY_JOIN})
/**
 * @description - Joins all elements of an array into a string. Note that unset indices are
 * represented as "" in the resulting string, and objects are represented as '{' Type(Object) '}'.
 * @param {Array} Arr - The array to join. If calling this method from an array instance, skip this
 * parameter completely, don't leave a space for it.
 * @param {String} [Delimiter=', '] - The string to separate each element of the array. If unset,
 * the default delimiter is a comma followed by a space.
 * @param {VarRef} [OutVar] - The variable to store the result in. This can be slightly faster for
 * very large strings, compared to getting the string as a return value.
 * @param {Integer} [Start=1] - The index to start the join from.
 * @param {Integer} [Length] - The number of elements to join. If unset, the join will continue until
 * the end of the array.
 * @returns {String} - The joined string.
 */
ARRAY_JOIN(Arr, Delimiter := ', ', &OutVar?, Start := 1, Length?) {
    OutVar := '', Start--
    while ++Start <= (IsSet(Length) && Start + Length < Arr.Length ?  Start + Length : Arr.Length) {
        if Arr.Has(Start) {
            if IsObject(Item := Arr[Start])
                OutVar .= '{' Type(Item) '}' Delimiter
            else
                OutVar .= String(Item) Delimiter
        } else
            OutVar .= '""' Delimiter
    }
    return Trim(OutVar, Delimiter)
}

Array.Prototype.DefineProp('JoinA', {Call: ARRAY_JOINA})
/**
 * @description - Joins all elements of an array into a string.
 * @param {Array} Arr - The array to join. If calling this method from an array instance, skip this
 * parameter completely, don't leave a space for it.
 * @param {String} [Delimiter=', '] - The string to separate each element of the array. If unset,
 * the default delimiter is a comma followed by a space.
 * @param {VarRef} [OutVar] - The variable to store the result in. This can be slightly faster for
 * very large strings, compared to getting the string as a return value.
 * @param {Integer} [Start=1] - The index to start the join from.
 * @param {Integer} [Length] - The number of elements to join. If unset, the join will continue until
 * the end of the array.
 * @param {String} [UnsetItemString='""'] - The string to represent unset indices.
 * @param {Func|BoundFunc|Closure} [ObjectCallback=(Item) => '{' Type(Item) '}] - A fuction which
 * accepts the object as an argument and returns the string to add to the result string.
 * @returns {String} - The joined string.
 */
ARRAY_JOINA(Arr, Delimiter := ', ', &OutVar?, Start := 1, Length?, UnsetItemString := '""', ObjectCallback := (Item) => '{' Type(Item) '}') {
    OutVar := '', Start--
    while ++Start <= (IsSet(Length) && Start + Length < Arr.Length ?  Start + Length : Arr.Length) {
        if Arr.Has(Start) {
            if IsObject(Item := Arr[Start])
                OutVar .= ObjectCallback(Item) Delimiter
            else
                OutVar .= String(Item) Delimiter
        } else
            OutVar .= UnsetItemString Delimiter
    }
    return Trim(OutVar, Delimiter)
}

Array.Prototype.DefineProp('Reduce', {Call: ARRAY_REDUCE})
/**
 * @description - Implements Javascript's `array.reduce` in AutoHotkey. `Array.Prototype.Reduce` is
 * used to iterate upon the values in an array, using a VarRef parameter to generate a cumulative
 * result.
 * @param {Array} Arr - The array to iterate. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Func|BoundFunc|Closure} Callback - The function to execute on each element in the array.
 * The callback can accept two to four parameters:
 * - The accumulator. This must be VarRef.
 * - The current value being processed in the array.
 * - [Optional] The index of the current element being processed in the array.
 * - [Optional] The array reduce was called upon.
 * The function does not need a return value, and if it exists it is ignored.
 * @param {Any} [InitialValue] - The initial value of the accumulator. If not set, the first element
 * of the array will be used and iteration begins from the second element.
 * @param {Any} [Default] - The value to use when an array index is unset. If unset, that index
 * is skipped.
 * @returns {Any} - The value that results from the reduction.
 * @example
    arr := [1,2,,3,4,,,5]
    Callback := (&Accumulator, Value, *) => Accumulator += Value
    OutputDebug(arr.Reduce(Callback, , 1)) ; 18
   @
*/
ARRAY_REDUCE(Arr, Callback, InitialValue?, Default?) {
    i := 0
    while !Arr.Has(++i)
        continue
    if IsSet(InitialValue)
        Accumulator := InitialValue, i--
    else
        Accumulator := Arr[i]
    if IsSet(Default)
        _LoopWithDefault()
    else
        _Loop()
    return Accumulator

    _Loop() {
        while ++i <= Arr.Length {
            if !Arr.Has(i)
                continue
            Callback(&Accumulator, Arr[i], i, Arr)
        }
    }
    _LoopWithDefault() {
        while ++i <= Arr.Length
            Callback(&Accumulator, Arr.Has(i) ? Arr[i] : Default, i, Arr)
    }
}

Array.Prototype.DefineProp('Reverse', {Call: ARRAY_REVERSE})
/**
 * @description - Reverses the order of the elements in an array.
 * @param {Array} Arr - The array to reverse. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Integer} [Start=1] - The index to start the reverse from.
 * @param {Integer} [Length] - The number of elements to reverse. If unset, the reverse will continue
 * until the end of the array.
 * @returns {Array} - The reversed array.
 */
ARRAY_REVERSE(Arr, Start := 1, Length?) {
    Result := []
    if !IsSet(Length)
        Length := Arr.Length - Start + 1
    Result.Length := Length, End := Start + Length
    while --End >= Start {
        if Arr.Has(End)
            Result[A_Index] := Arr[End]
    }
    return Result
}

Array.Prototype.DefineProp('Slice', {Call: ARRAY_SLICE})
/**
 * @description - Extracts a section of an array and returns a new array. Does not mutate the
 * original array.
 * @param {Array} Arr - The array to slice. If calling this method from an array instance, skip this
 * parameter completely, don't leave a space for it.
 * @param {Integer} Start - The index to start the slice from.
 * @param {Integer} [Length] - The number of elements to include in the slice. If unset, the slice
 * will continue until the end of the array.
 * @returns {Array} - A new array containing the sliced elements.
 */
ARRAY_SLICE(Arr, Start := 1, Length?) {
    End := IsSet(Length) && Start + Length < Arr.Length ?  Start + Length : Arr.Length
    Result := [], Result.Length := End - Start + 1, Start--
    while ++Start <= End {
        if Arr.Has(Start)
            Result[A_Index] := Arr[Start]
    }
    return Result
}

Array.Prototype.DefineProp('Splice', {Call: ARRAY_SPLICE})
/**
 * @description - Adds and/or removes elements from an array. Mutates the original array and returns
 * the removed values.
 * @param {Array} Arr - The array to splice. If calling this method from an array instance, skip
 * this parameter completely, don't leave a space for it.
 * @param {Integer} Start - The index to start the splicing from.
 * @param {Integer} [Length] - The number of elements to remove. If unset, all elements from the
 * start index to the end of the array will be removed.
 * @param {Any:Variadic} [Items] - The elements to add to the array. If unset, no elements will be
 * added.
 * @returns {Array} - An array containing the removed elements.
 */
ARRAY_SPLICE(Arr, Start, Length?, Items*) {
    Result := []
    if Items.Length {
        i := 0
        if IsSet(Length) {
            Result.Length := Length
            if Items.Length >= Length {
                while ++i <= Min(Items.Length, Length) {
                    if Arr.Has(z := Start + i - 1)
                        Result[i] := Arr[z]
                    if Items.Has(i)
                        Arr[z] := Items[i]
                }
                if Items.Length > Length
                    Items.RemoveAt(1, --i), Arr.InsertAt(i+Start, Items*)
            } else {
                End := Start + Length - 1, Start--
                for Item in Items {
                    ++i, ++Start
                    if Arr.Has(Start)
                        Result[i] := Arr[Start]
                    if IsSet(Item)
                        Arr[Start] := Item
                    else
                        Arr[Start] := unset
                }
                s := Start
                while ++Start <= End
                    Arr.Has(Start) ? Result[++i] := Arr[Start] : ++i
                Arr.RemoveAt(s+1, End-s)
            }
        } else
            Arr.InsertAt(Start, Items*)
    } else {
        Result.Length := Length??(Arr.Length - Start + 1)
        End := Start + Result.Length - 1, Start--
        while ++Start <= End {
            if Arr.Has(Start)
                Result[A_Index] := Arr[Start]
        }
        Arr.RemoveAt(Start, Length??unset)
    }
    return Result
}

[/code]

[color=#800000][size=150]Commentary[/size][/color][color=#000000][size=125]
To use Array.Prototype.ForEach effectively, you should know how the [c]this[/c] parameter works, when it is to be used in [c]ForEach[/c], and when it should not be used. Here is an explanation and some examples.
- If iterating over an array using a callback that is NOT a class method, you should leave [c]ThisArg[/c] unset.
- If iterating over an array using a callback that is a BoundFunc created using [c]ObjBindMethod[/c], you should leave [c]ThisArg[/c] unset.
- If iterating over an array using a callback that is a class method, you need to pass something to [c]ThisArg[/c]. This does not necessarily need to be the instance object or the class object, but it could be. These are the scenarios to consider when defining the parameter:
-- It could be any type of value that is referenced within the method using the [c]this[/c] keyword. Typically, this is the class object or instance object itself.
-- If the callback method does not refer to [c]this[/c] at all, just pass any value, [c]0[/c] is fine, to [c]ThisArg[/c]. This is necessary to tell the function to use the correct loop.
-- If iterating over an array using a callback that is a class method, and you want to modify what [c]this[/c] refers to within the function, you should pass an object to [c]ThisArg[/c] that you want [c]this[/c] to refer to within the function. This can be useful for testing a range of values against a function, when internally the function would normally use [c]this[/c] to refer to its parent object. This allows you to rewrite only the part of the code that's relevant to your test, perhaps saving you some time and lines of code.

Examples:
[/size][/color]
[color=#800000][size=150]ForEach-Examples.ahk[/size][/color]
[code]

#Include <Array>

; Example 1: Standard usage.

MyFunc(Item, *) {
    OutputDebug('`nItem: ' Item)
}
Arr := [1,2,,4,,6,,,9]
Callback := MyFunc
Arr.ForEach(Callback) ; Leave `ThisArg` unset.

; ~~~~~

; Exampe 2: Using a default value.

MyFunc2(Item, *) {
    OutputDebug('`nItem: ' Item)
}
Arr := [1,2,,4,,6,,,9]
Callback := MyFunc2
Arr.ForEach(Callback, 'Not found!') ; Set a default value to be used for unset indices. Leave `ThisArg` unset.

; ~~~~~

; Example 3: Using an anonymous function.

; For anonymous functions, also leave `ThisArg` unset.
Arr := [1,2,,4,,6,,,9]
Arr.ForEach((Item, Index, *) => OutputDebug('`nIndex: ' Index '`tItem: ' Item))

; Example 4: Using `ObjBindMethod` on a class object.

class Test4 {
    static Call(Item, *) {
        OutputDebug('`nItem: ' Item * 2)
    }
}

Arr := [1,2,,4,,6,,,9]
Callback := ObjBindMethod(Test4, 'Call')
Arr.ForEach(Callback) ; Leave `ThisArg` unset because it is already bound to the function object.

; ~~~~~

; Example 5: Using a class method that is not bound, and the method does not refer to `this`.

class Test5 {
    static Call(Item, Index, Arr?) {
        OutputDebug('`n`nItem: ' Item '`tIndex: ' Index '`t``this``: ' this '`tArray:`n' Arr.Join())
    }
}

Arr := ['a', 'b', 'c', 'd', 'e']
Callback := Test5.Call
; `ThisArg` requires a value because the first parameter in a class method is the hidden `this`, so
; when `Array.Prototype.ForEach` calls the function object, the first parameter which it passes
; to the callback is going to be consumed by `this`. A good way to visualize this is to open this
; in a debugger and see which values are passed to `Test.Call`. Try one without the 0 in the
; `ThisArg` parameter, and see how it works. What you will see is that the first parameter
; is consumed by `this`, which in a typical function call, you wouldn't notice this, but within an
; external function call, it becomes apparent.
Arr.ForEach(Callback,, 0)

; ~~~~~

; Example 6: Using a class method that is not bound, and the method refers to `this`, and `this`
; refers to the class.

class Test6 {
    static Call(Item, *) {
        OutputDebug('`nItem: ' Item * this.factor)
    }
    static factor := 2
}

Arr := [1,2,,4,,6,,,9]
Callback := Test6.Call
; We must pass the object `Test` because `this` is referenced within the function, and that
; reference is intended to refer to `Test`.
Arr.ForEach(Callback,, Test6)

; ~~~~~

; Example 7: Using a class method with a value that we want to override within our callback function.

class Test7 {
    static Call(Item, *) {
        OutputDebug('`nItem: ' Item * this.factor)
    }
    static factor := 2
}
Multiplier := { factor: 3 }
Arr := [1,2,,4,,6,,,9]
Callback  := Test7.Call
; We pass `Multiplier` as `ThisArg` to modify what `this` refers to within the function.
; This allows us to test a new value against the function, without needing to modify our class object
; or make other changes, simplifying the testing process.
Arr.ForEach(Callback,, Multiplier)

[/code]

[color=#800000][size=150]Changelog[/size][/color]
[color=#000000][size=120]2025-01-29[/size][/color]
- Added [c]JoinA[/c], which is the same as [c]Join[/c] except it exposes two additional components as input parameters: The value which is used for unset indices, and the value which is used for items that are objects.
[color=#000000][size=120]2025-01-20[/size][/color]
- [b]*Breaking*[/b] Updated ForEach to accept a [c]Default[/c] parameter. This parameter is in the position where [c]ThisArg[/c] was previously, and [c]ThisArg[/c] is still the last but pushed back one space, so updating to this version would require moving the parameters.
- Fixed inefficient code in ARRAY_REVERSE
- Updated the ForEach examples to use class instance syntax, added details, clarified language, modified the structure of the examples to allow the entire set of examples to be run from within one document, added a separate [c]ForEach-Examples.ahk[/c] to the repository.
[color=#000000][size=120]2025-01-18[/size][/color]
- Uploaded library
